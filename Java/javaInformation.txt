( until 3장 자료형 Part 7 재네릭스 전까지)

What is JDL
: JDK is Java Development Kit의 약자. 자바 프로그램을 만들기 위해 필수임.

<Ordinary Type of Java Source Code>
    ClassName.java
    -- Code start --
        /*Class Block */
        public class ClassName {

            /*method block*/
            [ public | private | protected] [static] (return 자료형 | void) methodName (입력자료형 입력변수, ...) {
                명령문(statement);
                ...
            }

            /*method block */
            [ public | private | protected] [static] (return 자료형 | void) methodName (입력자료형 입력변수, ...) {
                명령문(statement);
                ...
            }
        }

    - Source code의 가장 바깥은 class 블록 && class명 == 소스파일명
    - [ public | private | protected]: Method의 접근제어자 택1 혹은 아무것도 없음.
    - [static]: 있으면 static method 없어도 ㄱㅊ
    - (return 자료형 | void).isRequired: 필수, return되는 자료형을 표시


<How to Compile Java and The Process of Compiling >
    <Compiling>
        javac(java compiler) => 자바 파일을 컴파일하는 과정에 사용되는 것 
        : 작성 소스코드를 기계어로 변환

        .java(자바 파일 or java source) => 우리가 작성하게 되는 자바 프로그램.

    <Whole Process>

        : Myprogram.java - Compiler -> Myprogram.class - Java VM(Virtual Machine) -> My Program
        Compiler: javac.exe / Java VM: java.exe
        .class file: JavaVM만 해석 가능

    Java VM의 사용으로 인하여 OS에 구애받지 않고 실행파일 사용 가능 /But 속도 느림.

    <How to excute the .class file>
        type: java theNameOfJavaClassFile(without .class)

<What is "public">
    public은 keyword이자 접근제어자 class 명 앞에 사용될 경우 다른 의미를 가짐
    class명과 파일명이 동일할 경우 class에 public을 붙여야 함.
        ex) HelloWorld.java / HelloWorld.class

<What is "method">
    method는 function과 동일한 개념, class 내부의 function은 method라고 한다.
    자바는 모든 것이 class이므로 자바 속 함수는 모두 method이다.

    main method(.isRequired) => 모든 프로그램의 시작과 끝을 관리하는 method

<What is 접근제어자(Access Modifier)>
    public: method의 접근제어자. 누구나 이 method에 접근 가능
     
<Java Keywords>
    static: 변수 or method에 사용 가능 / 메모리를 할당 받은 후로, 프로그램이 종료될 때까지 유지
        - Static variable(==class variable): 객체를 생성하지 않고 Static 자원 접근 가능
        - Static method: 객체 없이 호출 가능, 객체는 호출 불가능
            ex) 클래스명.메소드명 => 호출 가능

    void: method의 return 값이 없음을 의미.

<Difference between "Object" and "Instance">
    Object(객체): class의 타입으로 선언 -> Object
    Instance: 위의 object를 이용하여 객체에 메모리가 할당되는 순간 -> Instance

<Java DataType && Variables>
    
    Primitive 자료형: byte, short, int, long, double, float, boolean, char 등을 지칭함.
        - new라는 키워드로 객체를 생성할 수 없음.
        - byte = 1 byte
        - short = 2 byte
        - int = 4 byte
        - long = 8 byte
        - float = 4 byte
        - double = 8 byte
        - boolean = 1 byte
        - char = 2 byte
    
    Non-Primitive Data Types: 스스로 부를 수 있는 method들이 존재함.
        - null의 data값을 가질 수 있음. (Primitive DataType은 불가능함. value가 항상 존재.)
        - uppercase로 시작함.
        - 모두 동일한 크기를 지니고 있음.

    When we add the keyword "final" or "constant" infront of the variable, 
    others can't change the value, only reading is possible

    < 숫자형 >
    < 정수형 >

    int: 정수를 나타내는 자료형, 들어가는 범위는 long보다는 적다.

    long: int 형보다 더 큰 정수값을 담을 수 있는 자료형. 
        - 만약 int 이상의 값을 대입하게 되는 경우, 뒤에 대문자 L을 붙여주어야 한다.
            - 소문자도 가능하지만 숫자 1과의 구분이 어려우므로 대분자가 convention
        - * int의 범위 => -2147483648 ~ 2147483647
        - ex) long myNum = 15000000000L;

    < 실수형 >
    * double d2 = 1.234e2와 같은 표현을 사용할 수 있음.
        - e2는 10^2을 의미함.
        - 변수 선언을 해주는 과정에서 뒤에 d를 꼭 붙여주어야 함.
        - ex) double myNum = 19.99d;

    float: 자바의 실수를 표현하기 위한 자료형.
        - 표현 범위: -3.4 * 10^38 ~ 3.4 * 10^38
        - long과는 다르게 실수의 경우, double이 default임. float로 전환하기 위해서는 f or F를 접미사로 사용

        - ex) float Pi = 3.14F => F를 붙임으로서 float형

    double: float보다 더욱 큰 실수의 값을 나타낼 수 있는 자료형을 의미.
        - 표현 범위: -1.7 * 10^308 ~ 1.7 * 10^308

    < 8진수 or 16진수 >

    8진수와 16진수는 int를 이용하여 표시함.
        - 숫자 0으로 시작하면 8진수를 의미. / 숫자 0 + x의 형태로 시작하면 16진수를 의미함.

        - ex) int octal = 023; => 19
              int hex = 0xC; => 12

    < 증감 연산자 >

    ++ or --의 역할은 C에서의 작동과 동일하게 작동된다. 위치 및 기능 동일.
        
    boolean: 참 또는 거짓의 값을 갖는 자료형 => true or false
        - 주로 조건문에서 조건의 판단 기준으로 활용됨.

    char: 한 개의 문자만을 다루는 경우에 대한 자료형.
        - single quote로 감싸주어야 함. ex) char a1 = 'a';
        - char의 경우, 아스키 코드를 바탕으로 숫자로도 표현을 할 수 있다.
        - 유니코드의 형태로도 표현이 가능함.

        - ex) char a1 = 'a';
              char a2 = 97;
              char a3 = '\u0061'; ==> 3개의 출력값이 모두 a로 동일함.

    String[]: 문자열을 의미하는 자바의 자료형.([]가 있으므로 한 개가 아닌 여러 개로 이루어진 배열 의미.)
        - String[] args: args는 변수명, 살짝 convention
        - String 대문자 주의;
        - 2가지의 생성 방식을 택할 수 있음. 1. String a = "Im Woochan"; => Literal 표현하기
                                             String a = new String("Im Woochan"); => String 객체 생성.
        - 한 번 값이 지정되고 나면 변경 불가. immutable.
            - method들을 통한 변경은 모두 새로운 String 객체를 생성하는 과정임.

        - String이 가지고 있는 내장 method
            - equals: 두 개의 문자열이 동일한지를 비교하여 결과값을 boolean으로 return
                - ex) a.equals(b) ==> true or false
                - == 연산자를 사용하게 될 경우, 같은 객체인지를 확인하므로 같은 문자열에 대해 false가 될 수도 있음.
            
            - indexOf: 문자열의 특정 문자가 시작되는 index를 return(int)
                - ex) String a = "Hello Java";
                      a.indexOf("Java"); => 6 return

            - contains: 문자열에 특정 문자가 포함되어 있는 지에 대한 여부를 boolean으로 return
                - ex) a.contains("Java") => true or false

            - charAt: 문자열에서 특정 위치의 문자(char)를 return
                - a.charAt(6) => 'j' 

            - replaceAll: 문자열 중 특정 문자열을 다른 것으로 바꾸고자 하는 경우 사용.
                - ex) a.replaceAll("Java", "World") => 바꿀 부분, 바꿀 내용

            - substring: 문자열 중 특정 부분을 뽑아내는 경우.
                - ex) a.substring(0, 4) => index를 기준으로 0~4까지를 가져옴
                - 가져오는 범위는 0 <= a < 4 => 끝부분은 포함이 안됨.

            - toUpperCase: 문자열을 모두 대문자로 변경하는 경우. 소문자의 경우(toLowerCase)
                - a.toUpperCase() => 모두 대문자 변환

            - split: 문자열을 특정 구분자로 분리하는 method
                - ex) String a ="a:b:c:d";
                      String[] result = a.split(":") => result는 {"a", "b", "c", "d"}

        - 문자열 포매팅: C에서 print("%d")에서의 %d와 비슷한 듯
            - String.format("I eat %d apples.", 3) => %d(문자열 포맷 코드) 자리에 3이 들어감.
                - 문자열을 넣는 방법 String.format("I eat %ㄴ apples.", "five")
                - 해당 DataType의 변수를 넣어도 가능함.
                - 여러 개의 경우, 차례대로 나열하면 됨.
                - 문자열 포맷 코드
                    - %s: 문자열 => 자동으로 뒤의 값을 문자열로 변환.
                    - %c: 문자 1개
                    - %d: 정수
                    - %f: 부동소수
                    - %o: 8진수
                    - %x: 16진수
                    - %%: Literal(%를 표현하고 싶을 때)

                    - 포맷 코드 앞에 숫자를 대입하는 경우, 전체 문자열의 길이를 설정
                    - 숫자가 양수인 경우: 오른쪽 정렬 / 음수인 경우: 왼족 정렬
                    - .4f의 경우, . 뒤의 숫자가 소수점 뒤로부터 나올 숫자의 개수.

        - System.out.printf를 사용할 경우, 앞의 String.format없이 사용이 가능
            - ex) System.out.printf("I eat %d apples. ", 3) ==> "I eat 3 apples. "

            

    StringBuffer: 문자열을 추가하거나 변경하는 과정에서 사용하는 자료형. (mutable)
        - String보다 무거운 편에 속함. 메모리 사용량 High => 속도 느림.
        - 문자열의 변경 작업이 많지 않다면 사용하지 않음.

        - StringBuffer가 지닌 method

            - append: StringBuffer의 객체를 생성하고 문자열을 생성
                -ex) StringBuffer sb = new StringBuffer(); => StringBuffer의 객체 sb 생성
                     sb.append("Hello");
                     sb.append(" ");
                     sb.append("jump to java";
                     String result = sb.toString(); => toString method로 StringBuffer를 String으로 바꿀 수 있음.
                     => hello jump to java

                     String result ="";
                     result += "Hello";
                     result += " ";
                     result += "jump to java";
                     => 동일한 출력값을 지니지만, 메모리가 사용되는 과정이 다름
                     첫 번째 방법은 객체가 한 번만 생성됨.
                     두 번째 방법은 + 연산 과정이 진행될 때마다 새로운 String 객체를 생성함.(총 4번)
            
            - insert: 특정 위치에 원하는 문자열 삽입 가능
                - ex) sb.insert(index, "string")

            - substring: String에서의 작동 방식과 동일함.
                - ex) sb.substring(start, end) => start ~ end  전 꺼지의 문자열을 출력.
                    - start <= sb < end

            
    StringBuilder: StringBuffer는 멀티 스레드 환경이므로 안전한 반면 StringBuilder는 성능이 우수
        - 동기화를 고려할 필요가 없다면 StringBuilder를 사용.
    
    Array: 숫자 혹은 문자열들의 집합을 나타내기 위해서 사용하는 방식임. 자료형이 아닌 자료형의 집합.
        - Array는 자료형 옆에 [] 기호를 사용하여 나타낼 수 있다. => int [] (정수형 배열)
        - ex) String [] weaks = {"월", "화", "수", "목", "금", "토", "일"} 
        - ex) String [] weaks = new String[7] => 반드시 길이의 값을 명시
              weaks[0] = "월" => 다음의 방식으로도 구현 가능.

        - araayName.length => 배열의 길이를 출력함.

        - Array Error: ArrayIndexOutOfBoundsException => 길이 이상의 index 값을 요구한 경우
    
    List: 배열과 비슷한 자바의 자료형. 크기가 정해지지 X, 동적으로 변함. 
        - ArrayList, Vector, LinkedList 등의 List의 인터페이스를 구현한 자료형들이 존재함.
        
        - ArrayList: ArrayList를 사용하기 위해서는 import java.util.ArrayList를 해야함.

            - add: ArrayList 객체에 parameter를 추가해주기 위한 method
                - ex) ArrayList pitches = new ArrayList();
                      pitches.add("138");
                      pitches.add("129");
                      pitches.add("142"); => parameter는 가장 뒤의 index에 추가됨.
                - ArrayList.add(index, parameter) => 원하는 index에 parameter 삽입 가능.
            
            - get: ArrayList 내부 특정 index의 값을 추출 가능
                - ex) ArrayList.get(index) => parameter
            
            - size: ArrayList의 갯수를 return

            -contains: List안에 해당 parameter가 있는 지를 boolean 형태로 return

            - remove
                - 1. remove(객체): List에서 해당 객체를 삭제하고 삭제 결과를 boolean 값으로 return
                    - 만약 내부에 값이 존재하지 않는다면 false를 return
                - 2. remove(index): 해당 index의 항목을 삭제하고 삭제된 항목을 return
    Map
    Set

    사용자 정의 자료형: class를 이용하여 자료형을 만들 수 있음.

<How to make a Class's Object(Instance)>
    ClassName(Class의 자료형임을 의미) var = new ClassName();

<Java Naming Convention>
    <class>
        class명은 명사로 한다.
        CamelCase 방식 따름
    
    <Method>
        method명은 동사로 한다.
        CamelCase 방식 따름
    
    <variable>
        짧지만 의미를 가져야 함
        순서를 나타내는 임수 변수 => i, j, k, m, n
        변수명에 _, $가 사용가능하지만 시작 문자로는 사용하지 않는다.

<What is Wrapper class in Java>
    primitive 자료형들의 경우, 각각 대응하는 Wrapper class들을 가지고 있게 된다.
        - 객체 지향적인 프로그래밍을 위해서는 자료형 대신 다음의 class를 사용하게 될 것이다.

        - int - Integer
          long - Long
          double - Double
          float - Float
          boolean - Boolean
          char - char

< What is Type Casting in Java >
    서로 다른 Data Type에서 값을 옮겨주는 과정에서 발생하는 것을 의미함.

    - int => boolean의 형태는 불가능함.

    - Widening Casting: converting a smaller type to larger type size
        - byte -> short -> char -> int -> long -> float -> double
        - 자동으로 작은 type이 큰 type으로 변환됨

    - Narrowing Casting: converting a larger type to a smaller size type
        - double -> float -> long -> int -> char -> short -> byte
        - 수동으로 variable 앞에 data type을 표시해주어야 함. ex) (float)
        - ex) double myDouble = 9.78d;
              int myInt = (int) myDouble; // Manual casting: double to int

< What is Operator in Java? >

    - Operator들의 종류 : Arithmetic | Assignment | Comparison | Logical | Bitwise

    - 기본적인 Arithmetic Operator의 경우, 다른 언어와 동일하다.
    -  Assignment Operator
        - ( = | += | -= | *= | /= | %= )은 생각하는 것과 동일함.
        - &= => ex) a &=b ==> a = a & b를 의미함. boolean type에는 사용할 수 없음. bit연산자처럼 생각하면 될듯.
        - |= => ex) a |= b => a = a | b
        - ^= => x ^=3 => x = x^3
        - >>= / <<=의 경우. 확실한 bit 연산자이다.